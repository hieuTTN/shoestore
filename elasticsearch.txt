Elasticsearch ---------------------------1. install elasticsearch and configsudo apt install openjdk-17-jdk- install curl if not found: sudo apt install curlcurl -fsSL https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo gpg --dearmor -o /usr/share/keyrings/elastic.gpgsudo apt updatesudo apt install elasticsearchip addr show: find ipv4 of device192.168.91.128// public portsudo ufw enablesudo ufw allow 9200sudo ufw allow 9200/tcpsudo ufw allow from 192.168.91.128 to any port 9200// public elasticsearchsudo nano /etc/elasticsearch/elasticsearch.ymladd: http.host: 0.0.0.0access: http://ip:92002. install and config kibanasudo apt install kibanasudo systemctl enable kibanasudo systemctl start kibanasudo nano /etc/kibana/kibana.ymlchange: server.host => "0.0.0.0"sudo systemctl restart kibana//public portsudo ufw allow 5601sudo ufw allow 5601/tcpaccess: http://ip:56013. install logstash port default: 5044sudo apt install logstashsudo systemctl start logstashsudo systemctl enable logstash4. install mysqlsudo apt install mysql-serversudo mysql -u root -pCREATE USER 'hieutv'@'%' IDENTIFIED BY '12345';GRANT ALL PRIVILEGES ON *.* TO 'newuser'@'%' WITH GRANT OPTION;sudo nano /etc/mysql/mysql.conf.d/mysqld.cnfchange bind-address=> 0.0.0.0change mysqlx-bind-address => 0.0.0.0sudo ufw allow 3306sudo ufw allow 3306/tcpsudo systemctl start mysql---- config logstash sync database to elasticsearch ------ auto sync insert, update, can't sync delete, but logstash can't sync relational objects, example: {	"id":1,"name":"hieutv","category":{"id":1}}must ElasticsearchRepository to insert or update//logstash locationusually, logstash on etc/logstashcopy file jar mysql-connector-java to folder logstashcreate file jdbc.conf in folder logstashopen file jdbc.conf and writeinput {  jdbc {    jdbc_driver_library => "/etc/logstash/mysql-connector-java-8.0.29.jar"    jdbc_driver_class => "com.mysql.jdbc.Driver"    jdbc_connection_string => "jdbc:mysql://192.168.91.128:3306/shoestore"    jdbc_user => "hieutv"     jdbc_password => "12345"    schedule => "* * * * *"    statement => "SELECT *,'category' as table_type from category"  } jdbc {     jdbc_driver_library => "/etc/logstash/mysql-connector-java-8.0.29.jar"    jdbc_driver_class => "com.mysql.jdbc.Driver"    jdbc_connection_string => "jdbc:mysql://192.168.91.128:3306/shoestore"    jdbc_user => "hieutv"    jdbc_password => "12345"    schedule => "* * * * *"    statement => "SELECT *,'product' as table_type from product"  }}filter {  if [table_type] == "category" {    mutate { add_field => { "[@metadata][index]" => "category" } }  } else if [table_type] == "product" {    mutate { add_field => { "[@metadata][index]" => "product" } }  }}output {  elasticsearch {    hosts => ["http://192.168.91.128:9200"]    index => "%{[@metadata][index]}"    document_id => "%{id}"  }  stdout { codec =>  "rubydebug"}}// runsudo nohup /usr/share/logstash/bin/logstash -f /etc/logstash/jdbc.conf &link test data: http://192.168.91.128:9200/product/_search------ query -------termquery: Search for exact (usually for find by id, code, date, keyword)matchQuery: approximate search (usually for find text)shoud: equal (or condition) in sqlmust: equal (and condition) in sqlBoolQueryBuilder boolQuery = QueryBuilders.boolQuery()		.should(QueryBuilders.multiMatchQuery(param, "name","category.name"))		.should(QueryBuilders.termQuery("code.keyword", param));NativeSearchQuery nativeSearchQuery = new NativeSearchQueryBuilder()		.withQuery(boolQuery)		.withPageable(pageable)		.build();SearchHits<ProductSearch> results = elasticsearchRestTemplate.search(nativeSearchQuery, ProductSearch.class, IndexCoordinates.of("product"));List<ProductSearch> products = results.getSearchHits().stream()		.map(hit -> hit.getContent())		.collect(Collectors.toList());return new PageImpl<>(products, pageable, results.getTotalHits());// dynamic query public Page<ProductSearch> searchFullProduct(List<Long> categoryIds, List<Long> trademarkIds, Double minPrice, Double maxPrice, Pageable pageable) {	BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()			.must(QueryBuilders.rangeQuery("price").gte(minPrice).lte(maxPrice));	if(categoryIds.size() > 0){		BoolQueryBuilder blcategory = QueryBuilders.boolQuery();		categoryIds.forEach(p->{			blcategory.should(QueryBuilders.termQuery("category.id", p));		});		boolQuery.must(blcategory);	}	if(trademarkIds.size() > 0){		BoolQueryBuilder bltrademark = QueryBuilders.boolQuery();		trademarkIds.forEach(p->{			bltrademark.should(QueryBuilders.termQuery("trademark.id", p));		});		boolQuery.must(bltrademark);	}	NativeSearchQuery nativeSearchQuery = new NativeSearchQueryBuilder()			.withQuery(boolQuery)			.withPageable(pageable)			.build();	SearchHits<ProductSearch> results = elasticsearchRestTemplate.search(nativeSearchQuery, ProductSearch.class, IndexCoordinates.of("product"));	List<ProductSearch> products = results.getSearchHits().stream()			.map(hit -> hit.getContent())			.collect(Collectors.toList());	return new PageImpl<>(products, pageable, results.getTotalHits());}